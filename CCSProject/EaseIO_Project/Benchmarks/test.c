#include <stdio.h>
#include <msp430.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>

#include "libPF/PF_sim.h"
#include "DSPLib.h"
#include "inputs/conv1.h"
/*EASEIO Libs*/
#include "libEaseIO/EASEIO.h"
#include <libalpaca/alpaca.h>
#include <libmsp/watchdog.h>


#define TEST_SIGNAL


#define MEM_SIZE 0x4
__nv uint8_t *data_src[MEM_SIZE];
__nv uint8_t *data_dest[MEM_SIZE];
__nv unsigned int data_size[MEM_SIZE];
void clear_isDirty() {}


void init();
void task_temp();

TASK(1,  task_temp)


/*APP vars*/
__nv volatile uint16_t avg_temp = 0;
__nv  uint64_t sample = 0;

/*TEST Variables */
__nv  uint64_t PF_number = 0;
__nv  uint64_t Re_exe_number = 0;
__nv expire_count =0;
__nv int expiration_array [30] = {1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
                                  1, 0, 0, 0, 1, 0, 0, 1, 0, 1,
                                  0, 1, 0, 1, 0, 0, 1, 0, 0, 1};

/* EASEIO FLags - they will be generated by compiler*/
__nv bool tempFlag;     // IO function flag  (temp)

/* EASEIO Private Copies of NV Var  - they will be generated by compiler*/
__nv  uint64_t sample_prive;

/*EASEIO Private Copies of IO function output vars  - they will be generated by compiler*/
__nv int tempPriv;

/* EASEIO Time Stamp - they will be generated by compiler*/
__nv uint32_t tempTimeStamp, expireTime;


uint32_t GetTime();

void task_temp()
{
    //-------Regional Privatization (will be injected by compiler)---------//
    if(!DMA_Data.DMA_Privatization[DMACounter-1]){
        sample_prive = sample;
        DMA_Data.DMA_Privatization[DMACounter-1] = COMPLETED;  // Regional Privatization Flags
    }else{
        sample = sample_prive;
    }
    //-------------------------------------------------------------//

    int temp;

    while(sample < 1000){
        expireTime = 10000;
        //--temp = call_IO(msp_sample_temperature(),"Timely" - Transformation)--//
        if (!(tempFlag) || !( GetTime() - tempTimeStamp < expireTime))
        {
            temp = msp_sample_temperature(); // annotated as @Timely
            tempTimeStamp = GetTime();
            tempPriv = temp;
            tempFlag = SET;
        }else{
            temp = tempPriv;
        }
        //---------------------------------------------------------------//

        avg_temp = avg_temp*sample + temp;
        sample ++;
        avg_temp /= sample;
        TRANSITION_TO(task_temp);
    }

    while(1);
}

static void init_hw()
{
    P3DIR = 0xFF;
    msp_watchdog_disable();
    PM5CTL0 &= ~LOCKLPM5;
}

void init()
{

    init_hw();
    __enable_interrupt();

}

//----IO Semantic Flags Cleaning Func - will be created by compiler--//
void Clean_flags(){
    tempFlag =false;
}
//-------------------------------------------------------//

ENTRY_TASK(task_temp)
INIT_FUNC(init)


uint32_t GetTime()
{
    if (expire_count == 30)
        expire_count = 0;
    expire_count++;
    return expiration_array[expire_count];
}
